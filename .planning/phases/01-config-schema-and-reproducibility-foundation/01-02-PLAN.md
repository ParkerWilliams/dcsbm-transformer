---
phase: 01-config-schema-and-reproducibility-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/reproducibility/__init__.py
  - src/reproducibility/seed.py
  - src/reproducibility/git_hash.py
  - src/results/schema.py
  - tests/test_reproducibility.py
autonomous: true
requirements:
  - TRNG-02
  - TRNG-07

must_haves:
  truths:
    - "Calling set_seed(42) twice produces identical sequences from random, numpy, and torch"
    - "verify_seed_determinism(42) returns True"
    - "get_git_hash() returns a non-empty string matching the git short SHA of the current commit"
    - "get_git_hash() appends '-dirty' when the working tree has uncommitted changes"
    - "get_git_hash() returns 'unknown' when not in a git repository"
    - "write_result() includes code_hash from get_git_hash() in metadata block"
  artifacts:
    - path: "src/reproducibility/seed.py"
      provides: "set_seed, verify_seed_determinism, seed_worker functions"
      exports: ["set_seed", "verify_seed_determinism", "seed_worker"]
    - path: "src/reproducibility/git_hash.py"
      provides: "get_git_hash function with dirty detection"
      exports: ["get_git_hash"]
    - path: "tests/test_reproducibility.py"
      provides: "Tests proving seed determinism and git hash behavior"
      min_lines: 50
  key_links:
    - from: "src/reproducibility/seed.py"
      to: "torch, numpy, random"
      via: "set_seed seeds all three RNG sources plus CUDA determinism flags"
      pattern: "random\\.seed.*np\\.random\\.seed.*torch\\.manual_seed"
    - from: "src/reproducibility/git_hash.py"
      to: "subprocess"
      via: "git rev-parse --short HEAD with error handling"
      pattern: "git.*rev-parse.*--short.*HEAD"
    - from: "src/results/schema.py"
      to: "src/reproducibility/git_hash.py"
      via: "write_result calls get_git_hash() for metadata.code_hash"
      pattern: "get_git_hash"
---

<objective>
Create seed management for full reproducibility and git hash tracking for code provenance.

Purpose: TRNG-02 requires all randomness to be controlled from a single master seed so experiments are reproducible. TRNG-07 requires the git commit hash to be captured with results so any experiment can be traced back to exact code. These complete Phase 1's reproducibility foundation.

Output: Reproducibility module (`src/reproducibility/`) with seed management and git hash capture. Updated result writer that integrates git hash. Tests proving determinism and correct git hash behavior.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-config-schema-and-reproducibility-foundation/01-CONTEXT.md
@.planning/phases/01-config-schema-and-reproducibility-foundation/01-RESEARCH.md
@.planning/phases/01-config-schema-and-reproducibility-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Seed management and git hash modules</name>
  <files>
    src/reproducibility/__init__.py
    src/reproducibility/seed.py
    src/reproducibility/git_hash.py
  </files>
  <action>
Create the reproducibility module:

**src/reproducibility/seed.py:**
- `set_seed(seed: int) -> None`: Seeds all RNG sources for full reproducibility. Must set, in this order:
  1. `random.seed(seed)`
  2. `np.random.seed(seed)`
  3. `torch.manual_seed(seed)` (covers CPU)
  4. `torch.cuda.manual_seed_all(seed)` (covers all GPUs)
  5. `torch.backends.cudnn.deterministic = True`
  6. `torch.backends.cudnn.benchmark = False`
  7. `torch.use_deterministic_algorithms(True)`
  8. `os.environ["CUBLAS_WORKSPACE_CONFIG"] = ":4096:8"`
  Must be called before any random operations. Include docstring explaining each step.

- `verify_seed_determinism(seed: int) -> bool`: Sets seed, generates 10 values from each of random, numpy, torch. Resets seed, generates 10 more. Returns True if all three sequences are identical. This is the self-test that proves seed control works.

- `seed_worker(worker_id: int) -> None`: Worker init function for PyTorch DataLoader reproducibility. Derives worker seed from `torch.initial_seed() % 2**32`, seeds numpy and random with it. Include usage docstring showing the DataLoader pattern with Generator.

**src/reproducibility/git_hash.py:**
- `get_git_hash() -> str`: Returns the short git SHA with dirty detection.
  1. Run `subprocess.check_output(["git", "rev-parse", "--short", "HEAD"], stderr=subprocess.DEVNULL)` — decode and strip
  2. If CalledProcessError or FileNotFoundError, return `"unknown"`
  3. Run `subprocess.check_output(["git", "diff", "--quiet"], stderr=subprocess.DEVNULL)` to check for uncommitted changes
  4. If that raises CalledProcessError (meaning there are changes), append `-dirty` to the SHA
  5. Also check `git diff --quiet --cached` for staged changes — append `-dirty` if either staged or unstaged changes exist
  Return format: `"a3f9c1d"` (clean) or `"a3f9c1d-dirty"` (dirty)

**src/reproducibility/__init__.py:**
- Re-export: `set_seed`, `verify_seed_determinism`, `seed_worker`, `get_git_hash`
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -c "
from src.reproducibility import set_seed, verify_seed_determinism, get_git_hash
# Seed determinism
assert verify_seed_determinism(42), 'Seed determinism failed'
assert verify_seed_determinism(123), 'Seed determinism failed for seed 123'
# Git hash
gh = get_git_hash()
assert gh != '', 'Git hash should not be empty'
assert gh != 'unknown' or True, 'OK if not in git repo'
print(f'Git hash: {gh}')
print('ALL CHECKS PASSED')
"</automated>
  </verify>
  <done>
set_seed controls random, numpy, torch, and CUDA determinism from a single seed. verify_seed_determinism proves identical sequences on repeated seeding. get_git_hash returns short SHA with -dirty suffix for uncommitted changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire git hash into result writer and add reproducibility tests</name>
  <files>
    src/results/schema.py
    tests/test_reproducibility.py
  </files>
  <action>
Integrate git hash into the result writer and create comprehensive reproducibility tests:

**src/results/schema.py** (modify existing from Plan 01-01):
- Import `get_git_hash` from `src.reproducibility.git_hash`
- In `write_result()`, replace the placeholder `"unknown"` code_hash with `get_git_hash()` call
- The metadata block should now read: `"code_hash": get_git_hash()` instead of `"code_hash": "unknown"`
- Ensure the import is at the top of the file

**tests/test_reproducibility.py** — pytest tests:

Seed determinism tests:
- `test_set_seed_random_determinism()`: set_seed(42), generate 100 random.random() values, set_seed(42) again, generate 100 more, assert equal
- `test_set_seed_numpy_determinism()`: Same pattern with np.random.rand(100)
- `test_set_seed_torch_determinism()`: Same pattern with torch.rand(100)
- `test_set_seed_cross_seed_different()`: set_seed(42) produces different sequences than set_seed(99)
- `test_verify_seed_determinism_passes()`: assert verify_seed_determinism(42) is True
- `test_seed_worker_determinism()`: Simulate the worker pattern — set torch manual seed, call seed_worker(0), verify numpy and random produce deterministic values

Git hash tests:
- `test_get_git_hash_returns_string()`: get_git_hash() returns a string, not None
- `test_get_git_hash_format()`: If not "unknown", result matches regex `^[0-9a-f]{7,}(-dirty)?$`
- `test_get_git_hash_not_empty()`: Result is non-empty

Integration test:
- `test_write_result_includes_code_hash(tmp_path)`: Call write_result with a valid config and metrics, load the resulting result.json, verify metadata.code_hash is a non-empty string (either a git hash or "unknown")
- `test_full_reproducibility_flow()`: Create ANCHOR_CONFIG, set_seed(config.seed), verify determinism, get git hash, create a result dict, validate it — the complete Phase 1 flow
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -m pytest tests/test_reproducibility.py -v</automated>
  </verify>
  <done>
write_result includes live git hash in metadata.code_hash. All seed determinism tests pass (random, numpy, torch independently verified). Git hash format tests pass. Integration test proves the full Phase 1 flow: config -> seed -> git hash -> result validation.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` — All tests pass (config, results, and reproducibility)
2. `python -c "from src.reproducibility import verify_seed_determinism; assert verify_seed_determinism(42)"` — Seed determinism self-test
3. `python -c "from src.reproducibility import get_git_hash; h = get_git_hash(); print(h); assert h and isinstance(h, str)"` — Git hash works
4. `python -c "
from src.config import ANCHOR_CONFIG, config_to_json, config_from_json, config_hash
from src.reproducibility import set_seed, verify_seed_determinism, get_git_hash
set_seed(ANCHOR_CONFIG.seed)
assert verify_seed_determinism(ANCHOR_CONFIG.seed)
h = get_git_hash()
print(f'Config hash: {config_hash(ANCHOR_CONFIG)}')
print(f'Git hash: {h}')
print(f'Round-trip: {config_hash(ANCHOR_CONFIG) == config_hash(config_from_json(config_to_json(ANCHOR_CONFIG)))}')
print('PHASE 1 COMPLETE')
"` — Full end-to-end verification
</verification>

<success_criteria>
- set_seed() controls random, numpy, torch, and CUDA from single seed
- verify_seed_determinism() returns True for any valid seed
- get_git_hash() returns short SHA with -dirty flag when appropriate
- write_result() includes live code_hash in metadata
- All tests in tests/test_reproducibility.py pass
- Full Phase 1 flow works end-to-end: config -> seed -> git hash -> result
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-schema-and-reproducibility-foundation/01-02-SUMMARY.md`
</output>
