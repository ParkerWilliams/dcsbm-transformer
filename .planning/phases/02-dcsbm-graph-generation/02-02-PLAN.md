---
phase: 02-dcsbm-graph-generation
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/graph/jumpers.py
  - src/graph/validation.py
  - src/graph/__init__.py
  - tests/test_jumpers.py
autonomous: true
requirements:
  - GRPH-02
  - GRPH-04

must_haves:
  truths:
    - "Block jumper vertices are designated with r values from the discrete set {0.5w, 0.7w, 0.9w, 1.0w, 1.1w, 1.3w, 1.5w, 2.0w} rounded to nearest integer"
    - "Each block has at least 1 jumper (floor rounding with minimum 1)"
    - "Each jumper's target block is different from its source block"
    - "For each jumper vertex with jump length r, valid paths of length r to the target block exist (reachability)"
    - "For each jumper vertex with jump length r, paths of length r to non-target blocks also exist (non-triviality)"
    - "Jumper reassignment retries up to block_size/2 times before falling back to full graph regeneration"
    - "All r values from the discrete set are represented across jumpers in the graph"
  artifacts:
    - path: "src/graph/jumpers.py"
      provides: "JumperInfo dataclass, designate_jumpers, R_SCALES constant"
      exports: ["JumperInfo", "designate_jumpers", "R_SCALES"]
    - path: "src/graph/validation.py"
      provides: "Non-triviality verification using sparse matrix-vector reachability"
      exports: ["check_non_trivial", "verify_all_jumpers", "reachable_blocks_at_distance"]
  key_links:
    - from: "src/graph/jumpers.py"
      to: "src/graph/validation.py"
      via: "designate_jumpers calls verify_all_jumpers to validate non-triviality after designation"
      pattern: "verify_all_jumpers"
    - from: "src/graph/jumpers.py"
      to: "src/graph/types.py"
      via: "designate_jumpers accepts GraphData and returns list of JumperInfo"
      pattern: "GraphData.*JumperInfo"
    - from: "src/graph/validation.py"
      to: "scipy.sparse"
      via: "reachable_blocks_at_distance uses iterative sparse matrix-vector multiplication with binary clipping"
      pattern: "csr_matrix"
---

<objective>
Implement block jumper designation with variable r values and non-triviality verification.

Purpose: Block jumper rules define the ground-truth "violations" that the transformer must learn. Each jumper vertex has a specific target block that walks must reach after r steps. The non-triviality check ensures that reaching the target block is neither impossible (no paths exist) nor trivial (all paths lead there). Variable r values per graph (rather than per config) dramatically reduce the sweep grid while providing richer data per experiment.

Output: Jumper designation module with non-triviality verification, reassignment retry logic, and comprehensive tests.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-dcsbm-graph-generation/02-CONTEXT.md
@.planning/phases/02-dcsbm-graph-generation/02-RESEARCH.md
@src/graph/types.py
@src/graph/dcsbm.py
@src/config/experiment.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Non-triviality verification using sparse reachability</name>
  <files>
    src/graph/validation.py
  </files>
  <action>
**src/graph/validation.py** — Path-based validation:

`reachable_blocks_at_distance(adj: scipy.sparse.csr_matrix, vertex: int, r: int, block_assignments: np.ndarray, K: int) -> set[int]`:
- Compute which blocks are reachable from `vertex` in exactly `r` steps
- Use iterative sparse vector-matrix multiplication:
  - Start with indicator vector: `vec = scipy.sparse.csr_matrix(([1.0], ([0], [vertex])), shape=(1, n))`
  - For step in range(r): `vec = vec @ adj`; clip to binary: `vec.data[:] = np.minimum(vec.data, 1.0)`
  - This prevents integer overflow from path counting (paths grow exponentially)
- Extract reachable vertices: `reachable = vec.nonzero()[1]`
- Return set of blocks: `{block_assignments[v] for v in reachable}`

`check_non_trivial(adj: scipy.sparse.csr_matrix, vertex: int, target_block: int, r: int, block_assignments: np.ndarray, K: int) -> bool`:
- Get reachable blocks at distance r
- Return True if BOTH conditions hold:
  1. `target_block in reachable_blocks` (paths to target exist)
  2. `len(reachable_blocks) > 1` or `reachable_blocks != {target_block}` (paths to non-target exist)
- Equivalently: target is reachable AND at least one non-target block is also reachable

`verify_all_jumpers(adj: scipy.sparse.csr_matrix, jumpers: list, block_assignments: np.ndarray, K: int) -> list[tuple[int, str]]`:
- For each jumper in jumpers list:
  - Call check_non_trivial(adj, jumper.vertex_id, jumper.target_block, jumper.r, block_assignments, K)
  - If fails: append (index, reason) to failures list
  - Reason: "no paths to target block" if target unreachable, "only target block reachable (trivial)" if only target is reachable
- Return list of (jumper_index, failure_reason) tuples

Import logging: `log = logging.getLogger(__name__)`
Log at DEBUG level the reachable blocks for each jumper check.
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -c "
from src.graph.validation import reachable_blocks_at_distance, check_non_trivial
import scipy.sparse
import numpy as np
# Create a simple 4-vertex graph: 0->1->2->3, 0->3 (two paths from 0, different blocks)
adj = scipy.sparse.csr_matrix(np.array([
    [0,1,0,1],
    [0,0,1,0],
    [0,0,0,1],
    [1,0,0,0]
], dtype=np.float64))
blocks = np.array([0,0,1,1])
# From vertex 0 at distance 2: 0->1->2 (block 1) and 0->3->0 (block 0)
reachable = reachable_blocks_at_distance(adj, 0, 2, blocks, 2)
assert 0 in reachable and 1 in reachable, f'Reachable: {reachable}'
# Non-trivial: target block 1, r=2 -- should be True (reaches both blocks)
assert check_non_trivial(adj, 0, 1, 2, blocks, 2), 'Should be non-trivial'
print('ALL CHECKS PASSED')
"</automated>
  </verify>
  <done>
reachable_blocks_at_distance computes block-level reachability at exact distance r using sparse iteration with binary clipping. check_non_trivial verifies both target reachability and non-triviality. verify_all_jumpers batch-checks all jumpers and returns failure details.
  </done>
</task>

<task type="auto">
  <name>Task 2: Block jumper designation with variable r and reassignment retry</name>
  <files>
    src/graph/jumpers.py
    src/graph/__init__.py
    tests/test_jumpers.py
  </files>
  <action>
**src/graph/jumpers.py** — Jumper designation:

Module-level constant:
`R_SCALES: tuple[float, ...] = (0.5, 0.7, 0.9, 1.0, 1.1, 1.3, 1.5, 2.0)` — the fixed set of r scale factors per CONTEXT.md

`@dataclass(frozen=True, slots=True)`
`JumperInfo`:
- `vertex_id: int` — the jumper vertex
- `source_block: int` — block the jumper belongs to
- `target_block: int` — block the walk must reach after r steps
- `r: int` — jump length in steps (rounded from scale * w)

`compute_r_values(w: int) -> list[int]`:
- Return `[max(1, round(scale * w)) for scale in R_SCALES]`
- Deduplicate (different scales may produce the same r after rounding): use dict.fromkeys to preserve order while deduplicating
- Return as sorted list

`designate_jumpers(graph_data: GraphData, config: ExperimentConfig, rng: np.random.Generator, max_reassign_per_vertex: int | None = None) -> list[JumperInfo]`:
- Extract w from config.training.w
- Compute r_values = compute_r_values(w)
- n_jumpers_per_block = config.graph.n_jumpers_per_block
- If max_reassign_per_vertex is None: max_reassign_per_vertex = graph_data.block_size // 2
- For each block b (0..K-1):
  - Get vertices in block: `block_vertices = [v for v in range(n) if graph_data.block_assignments[v] == b]`
  - Select n_jumpers_per_block vertices randomly (without replacement) using rng
  - Distribute r_values across jumpers: cycle through r_values using modulo (jumper i gets r_values[i % len(r_values)])
  - For each selected jumper vertex v with assigned r:
    - Choose target_block randomly from blocks != b using rng
    - Check non-triviality: `check_non_trivial(adj, v, target_block, r, block_assignments, K)`
    - If non-trivial: create JumperInfo and add to list
    - If NOT non-trivial: reassignment loop:
      - Try up to max_reassign_per_vertex different vertices from the same block
      - For each candidate vertex c (not already a jumper):
        - Check non-triviality for c with same target_block and r
        - If passes: use c instead of v, break
      - If all candidates fail: log warning, this jumper is skipped (will be noted in metadata)
- Assert: all r_values from compute_r_values(w) appear in at least one JumperInfo (warn if not, but don't fail — small blocks may not cover all r values)
- Return list of JumperInfo sorted by (source_block, vertex_id)

**src/graph/__init__.py** update:
- Add re-exports: `JumperInfo`, `designate_jumpers`, `R_SCALES`, `compute_r_values`, `check_non_trivial`, `verify_all_jumpers`, `reachable_blocks_at_distance`

**tests/test_jumpers.py** — pytest tests:

`test_compute_r_values_anchor()`:
- w=64: r_values should include round(0.5*64)=32, round(0.7*64)=45, round(0.9*64)=58, round(1.0*64)=64, round(1.1*64)=70, round(1.3*64)=83, round(1.5*64)=96, round(2.0*64)=128
- Assert all expected values present (after deduplication)

`test_designate_jumpers_anchor_config()`:
- Generate graph with ANCHOR_CONFIG
- Call designate_jumpers
- Assert total jumpers == n_jumpers_per_block * K (8 with defaults: 2 per block, 4 blocks)
- Assert each jumper's source_block != target_block
- Assert all jumpers pass check_non_trivial

`test_all_r_values_represented()`:
- Generate graph with anchor config
- Designate jumpers
- Collect unique r values from jumpers
- Assert all values from compute_r_values(64) are present (or warn if coverage is incomplete — depends on jumper count vs r count)
- NOTE: With 2 jumpers per block * 4 blocks = 8 jumpers and 8 r_values, each r should appear once

`test_jumper_target_block_different_from_source()`:
- All jumpers have source_block != target_block

`test_non_trivial_verification_on_real_graph()`:
- Generate anchor graph, designate jumpers
- For each jumper: verify check_non_trivial returns True
- Also verify paths exist to target AND non-target blocks

`test_jumper_reassignment_on_failure()`:
- Create a small graph where a specific vertex fails non-triviality
- Verify that designate_jumpers tries alternative vertices

`test_jumper_info_frozen()`:
- JumperInfo is immutable (frozen dataclass)

`test_minimum_one_jumper_per_block()`:
- Even with very small n_jumpers_per_block (1), each block has at least 1 jumper
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -m pytest tests/test_jumpers.py -v</automated>
  </verify>
  <done>
Block jumpers are designated with variable r values covering all scales from R_SCALES. Each jumper has a target block different from its source block. Non-triviality is verified for all jumpers. Reassignment retry finds alternative vertices when initial choice fails. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_jumpers.py -v` — All jumper and validation tests pass
2. `python -c "
from src.graph import generate_dcsbm_graph, designate_jumpers, compute_r_values
from src.config import ANCHOR_CONFIG
import numpy as np
g = generate_dcsbm_graph(ANCHOR_CONFIG)
rng = np.random.default_rng(ANCHOR_CONFIG.seed)
jumpers = designate_jumpers(g, ANCHOR_CONFIG, rng)
r_vals = compute_r_values(ANCHOR_CONFIG.training.w)
print(f'Jumpers: {len(jumpers)}, r_values: {sorted(set(j.r for j in jumpers))}')
print(f'Expected r_values: {r_vals}')
for j in jumpers:
    print(f'  v={j.vertex_id} block={j.source_block} target={j.target_block} r={j.r}')
"` — Jumpers designated with all r values represented
3. `python -m pytest tests/test_graph_generation.py tests/test_jumpers.py -v` — All Phase 2 tests pass together
</verification>

<success_criteria>
- Block jumpers designated with r values from all 8 scale factors
- compute_r_values(64) produces [32, 45, 58, 64, 70, 83, 96, 128]
- Each jumper has target_block != source_block
- All jumpers pass non-triviality check (paths to target AND non-target blocks exist at distance r)
- Reassignment retry logic works when a vertex fails non-triviality
- Minimum 1 jumper per block regardless of fraction setting
- JumperInfo is frozen and immutable
- All tests in tests/test_jumpers.py pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-dcsbm-graph-generation/02-02-SUMMARY.md`
</output>
