---
phase: 03-walk-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/walk/__init__.py
  - src/walk/types.py
  - src/walk/compliance.py
  - src/walk/generator.py
  - tests/test_walk_generator.py
autonomous: true
requirements:
  - WALK-01
  - WALK-04

must_haves:
  truths:
    - "Directed random walks follow only valid directed edges in the DCSBM graph"
    - "Walks starting from jumper vertices produce 100% rule-compliant guided paths"
    - "Every jumper encounter during a walk is recorded with vertex_id, step, target_block, and expected_arrival_step"
    - "Nested jumper constraints are satisfied simultaneously via joint path-count weighting"
    - "Compliant paths are sampled uniformly over all valid length-r paths (not biased to specific routes)"
  artifacts:
    - path: "src/walk/types.py"
      provides: "WalkCorpus and JumperEvent dataclasses"
      contains: "JumperEvent"
    - path: "src/walk/compliance.py"
      provides: "Path-count precomputation and guided step logic"
      exports: ["precompute_path_counts", "guided_step"]
    - path: "src/walk/generator.py"
      provides: "Walk generation functions (batch and guided)"
      exports: ["generate_walks"]
    - path: "tests/test_walk_generator.py"
      provides: "Tests for walk generation correctness"
      min_lines: 80
  key_links:
    - from: "src/walk/generator.py"
      to: "src/walk/compliance.py"
      via: "guided_step called during jumper-containing walk generation"
      pattern: "guided_step\\("
    - from: "src/walk/generator.py"
      to: "src/graph/types.py"
      via: "GraphData adjacency CSR matrix for neighbor access"
      pattern: "graph_data\\.adjacency"
    - from: "src/walk/compliance.py"
      to: "scipy.sparse"
      via: "Sparse matrix-vector multiplication for path-count precomputation"
      pattern: "adj\\s*@"
---

<objective>
Implement the core walk generation engine: path-count precomputation for guided walking, vectorized batch walk generation for unguided walks, per-walk guided generation with jumper constraint satisfaction, and jumper event metadata tracking.

Purpose: Provide the fundamental walk generation capability that produces 100% rule-compliant directed random walks on DCSBM graphs, with complete jumper encounter metadata for downstream evaluation (Phase 6).

Output: `src/walk/` module with types, compliance, and generator submodules; test suite proving walk correctness.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-walk-generation/03-CONTEXT.md
@.planning/phases/03-walk-generation/03-RESEARCH.md

@src/graph/types.py
@src/graph/jumpers.py
@src/graph/validation.py
@src/graph/cache.py
@src/config/experiment.py
@src/config/hashing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Walk types and path-count precomputation</name>
  <files>
    src/walk/__init__.py
    src/walk/types.py
    src/walk/compliance.py
  </files>
  <action>
Create `src/walk/` package with three files:

**src/walk/types.py** — Data structures:
- `JumperEvent` frozen dataclass (slots=True): `vertex_id: int`, `step: int`, `target_block: int`, `expected_arrival_step: int`. Represents a single jumper encounter during walk generation.
- `WalkResult` frozen dataclass: `walks: np.ndarray` (int32, shape num_walks x walk_length), `events: list[list[JumperEvent]]` (per-walk event lists), `walk_seeds: np.ndarray` (int64, per-walk seeds for reproducibility).

**src/walk/compliance.py** — Path-count precomputation and guided step logic:

1. `precompute_path_counts(adj: csr_matrix, block_assignments: np.ndarray, K: int, max_r: int) -> dict[int, list[np.ndarray]]`:
   - For each target block tb in range(K):
     - Initialize N[0] = indicator vector where block_assignments == tb (float64)
     - For k = 1 to max_r: N[k] = adj @ N[k-1] as dense array, then normalize by max value (prevent overflow per research pitfall 1). If max is 0, leave as zeros.
     - Store all N[0..max_r] as list of 1D numpy arrays
   - Return dict mapping target_block -> list of path-count vectors
   - Use `np.asarray(adj @ N_prev).ravel()` to handle sparse-to-dense conversion

2. `guided_step(vertex: int, active_constraints: list[tuple[int, int]], step: int, path_counts: dict, indptr: np.ndarray, indices: np.ndarray, rng: np.random.Generator) -> int | None`:
   - Get neighbors of vertex from CSR indptr/indices arrays
   - Initialize weights = ones(len(neighbors), float64)
   - For each (deadline, target_block) in active_constraints:
     - remaining = deadline - step
     - If remaining <= 0: skip (past deadline)
     - Look up path_counts[target_block][remaining - 1][neighbors] (remaining-1 because choosing NEXT vertex leaves remaining-1 more steps — per research pitfall 2)
     - Multiply weights element-wise with looked-up values
   - If total weight sum == 0: return None (infeasible joint constraint)
   - Return rng.choice(neighbors, p=weights / total)

**src/walk/__init__.py** — Empty initially (will be populated in Plan 02 with public API).

Key implementation notes:
- Follow the research code examples closely for precompute_path_counts and guided_step
- Use CSR indptr/indices directly (not converting to adjacency lists) for consistency with Phase 2
- The adj matrix used for path counts is the TRANSPOSE of what's used for walking: path_counts measure "how many paths lead FROM v TO target_block in k steps" — but we walk FORWARD. Since the graph is directed, we need adj (forward edges) for walking and adj.T (backward edges) for path counting. WAIT: Actually, reconsider. The path-count vector N[k] at position v gives the number of paths of length k from v to the target block. adj @ N[k-1] propagates: for each vertex u, sum over neighbors v of N[k-1][v]. This counts paths of length k starting from u reaching target. So adj should be used directly (not transposed). The research code examples use `adj @ N_prev` which is correct for forward path counting when adj[u][v]=1 means edge u->v.
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -c "
from src.walk.types import JumperEvent, WalkResult
from src.walk.compliance import precompute_path_counts, guided_step
import numpy as np
# Verify imports work and functions are callable
je = JumperEvent(vertex_id=0, step=5, target_block=1, expected_arrival_step=10)
assert je.vertex_id == 0
print('Types and compliance module imports OK')
"</automated>
    <manual>Check that precompute_path_counts returns normalized vectors without NaN/Inf</manual>
  </verify>
  <done>JumperEvent and WalkResult dataclasses defined; precompute_path_counts returns dict of path-count vectors for all target blocks up to max_r; guided_step selects next vertex proportional to joint constraint weights or returns None for infeasible cases.</done>
</task>

<task type="auto">
  <name>Task 2: Walk generator with guided and batch modes</name>
  <files>
    src/walk/generator.py
    tests/test_walk_generator.py
  </files>
  <action>
**src/walk/generator.py** — Core walk generation with two modes:

1. `generate_single_guided_walk(start_vertex: int, walk_length: int, rng: np.random.Generator, graph_data: GraphData, jumper_map: dict[int, JumperInfo], path_counts: dict, indptr: np.ndarray, indices: np.ndarray) -> tuple[np.ndarray, list[JumperEvent]] | None`:
   - Create walk array of int32, length walk_length
   - walk[0] = start_vertex
   - Maintain active_constraints: list of (deadline_step, target_block) tuples
   - For step 1 to walk_length-1:
     - Check if walk[step-1] is in jumper_map. If so:
       - Record JumperEvent(vertex_id=walk[step-1], step=step-1, target_block=jumper.target_block, expected_arrival_step=step-1+jumper.r)
       - Add (step-1+jumper.r, jumper.target_block) to active_constraints
     - Remove any constraints where deadline <= step (past deadline)
     - If active_constraints is non-empty:
       - Use guided_step() to select next vertex
       - If guided_step returns None (infeasible): return None (caller discards)
     - Else (no active constraints):
       - Uniform random neighbor selection from CSR arrays (same as batch mode)
     - walk[step] = selected_next
   - Validate compliance: for each recorded event, check block_assignments[walk[event.expected_arrival_step]] == event.target_block (only if expected_arrival_step < walk_length)
   - Return (walk, events)

2. `generate_batch_unguided_walks(start_vertices: np.ndarray, walk_length: int, rng: np.random.Generator, indptr: np.ndarray, indices: np.ndarray) -> np.ndarray`:
   - Vectorized batch generation per research Pattern 2
   - walks = np.zeros((n_walks, walk_length), dtype=np.int32)
   - walks[:, 0] = start_vertices
   - For step 1 to walk_length-1:
     - current = walks[:, step-1]
     - starts = indptr[current]; ends = indptr[current+1]
     - degrees = ends - starts
     - offsets = (rng.random(n_walks) * degrees).astype(np.int64)
     - offsets = np.clip(offsets, 0, degrees - 1)
     - walks[:, step] = indices[starts + offsets]
   - Return walks

3. `generate_walks(graph_data: GraphData, jumpers: list[JumperInfo], config: ExperimentConfig, seed: int, target_n_walks: int, min_jumper_fraction: float = 0.5) -> WalkResult`:
   - Build jumper_map: {j.vertex_id: j for j in jumpers}
   - Extract CSR arrays: indptr = graph_data.adjacency.indptr, indices = graph_data.adjacency.indices
   - Compute max_r = max(j.r for j in jumpers)
   - Call precompute_path_counts(graph_data.adjacency, graph_data.block_assignments, graph_data.K, max_r)
   - Determine n_jumper_walks = ceil(target_n_walks * min_jumper_fraction) + some overgeneration margin (~3% per research)
   - Determine n_random_walks = target_n_walks - n_jumper_walks (will be generated as batch unguided, then checked for jumper encounters)
   - Master RNG = np.random.default_rng(seed)
   - Generate per-walk seeds from master RNG: walk_seeds = master_rng.integers(0, 2**63, size=n_total_to_generate) — per research Pattern for reproducibility (pitfall 4)
   - **Jumper-seeded walks** (guided): Start from jumper vertices (cycle through jumpers). For each walk, use per-walk RNG = default_rng(walk_seed). Call generate_single_guided_walk(). If returns None (infeasible), discard and try next seed. Collect until n_jumper_walks successful.
   - **Random-start walks** (batch): Start from uniformly random vertices. Generate batch using generate_batch_unguided_walks(). Then scan each walk for jumper encounters. If a random walk hits a jumper vertex, it needs guided regeneration — re-generate that individual walk using generate_single_guided_walk() with its per-walk seed. NOTE: random walks that never hit a jumper can remain as-is (they're jumper-free walks).
   - After all walks generated, validate:
     - Every walk follows valid directed edges (walk[step+1] is a neighbor of walk[step] in the CSR matrix)
     - Jumper-containing walks are 100% rule-compliant
     - At least min_jumper_fraction of walks contain a jumper event
     - Path diversity: each jumper vertex has at least 3 distinct compliant paths in corpus (check by looking at unique walk[step:step+r] segments for each jumper)
   - If insufficient jumper walks or path diversity fails, generate additional walks
   - Return WalkResult with walks, events, walk_seeds

**tests/test_walk_generator.py** — Tests:

1. `test_walks_follow_valid_edges`: Generate walks on a known small graph (5 vertices), verify every step follows a directed edge.
2. `test_guided_walk_compliance`: Create a small graph with 1 jumper, generate guided walks, verify block_assignments[walk[step+r]] == target_block for every jumper encounter.
3. `test_jumper_events_recorded`: Generate walks with jumpers, verify events list is non-empty and each event has correct fields.
4. `test_batch_unguided_walks_shape`: Verify output shape is (n_walks, walk_length) with dtype int32.
5. `test_nested_jumper_compliance`: Create a graph with 2 jumpers where one is hit during another's guided path. Verify both constraints are satisfied.
6. `test_path_count_normalization`: Verify precompute_path_counts returns no NaN or Inf values for a graph with max_r=64.
7. `test_reproducibility_same_seed`: Generate walks twice with the same seed and config, verify identical results.
8. `test_infeasible_walks_discarded`: Mock a scenario where guided_step returns None, verify the walk is discarded and replaced.

Use the anchor config (n=500, K=4) for integration-style tests (5-7). Use small synthetic graphs (n=10-20) for unit tests (1-4, 8).

For small test graphs: create a simple directed graph manually using scipy.sparse.csr_matrix where edges are known, create fake JumperInfo objects with known r values, and verify walk correctness against the known graph structure.
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -m pytest tests/test_walk_generator.py -x -v 2>&1 | tail -30</automated>
    <manual>Verify guided walks achieve 100% compliance on anchor config</manual>
  </verify>
  <done>generate_walks() produces WalkResult with valid directed walks; all jumper-containing walks are 100% rule-compliant; jumper events are recorded per-walk; per-walk seed isolation ensures reproducibility; at least 8 tests pass covering edge validity, compliance, events, nesting, normalization, reproducibility, and infeasibility handling.</done>
</task>

</tasks>

<verification>
1. All walks follow valid directed edges (no invalid transitions)
2. 100% of jumper-containing walks satisfy the block jumper rule at the correct step
3. Jumper events are recorded accurately for every encounter
4. Path-count vectors contain no NaN/Inf values
5. Same seed produces identical walks on repeated runs
6. `python -m pytest tests/test_walk_generator.py -x` passes
</verification>

<success_criteria>
- `src/walk/types.py` defines JumperEvent and WalkResult
- `src/walk/compliance.py` implements precompute_path_counts and guided_step
- `src/walk/generator.py` implements generate_walks with both guided and batch modes
- All tests in `tests/test_walk_generator.py` pass
- Guided walks achieve 100% rule compliance on the anchor config
- Walk generation is reproducible (same seed = same output)
</success_criteria>

<output>
After completion, create `.planning/phases/03-walk-generation/03-01-SUMMARY.md`
</output>
