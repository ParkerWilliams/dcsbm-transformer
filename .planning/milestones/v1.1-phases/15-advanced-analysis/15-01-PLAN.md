---
phase: 15-advanced-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/evaluation/pipeline.py
  - src/analysis/spectrum.py
  - tests/test_spectrum.py
autonomous: true
requirements: [SPEC-01, SPEC-02]
---

must_haves:
  truths:
    - "fused_evaluate stores top-k singular values per step in a separate spectrum dict alongside existing svd_metrics, for QK^T target only by default"
    - "save_evaluation_results writes spectrum_trajectories.npz with float16 arrays keyed as qkt.layer_N.spectrum with shape [n_sequences, n_steps, k]"
    - "spectral_curvature applies Savitzky-Golay smoothing (window=7, polyorder=3) then computes discrete Frenet-Serret curvature from finite differences"
    - "spectral_torsion computes discrete torsion from first, second, and third derivatives of the smoothed spectrum trajectory"
    - "ordering crossing detection identifies and masks steps where adjacent singular values swap order"
    - "curvature returns NaN at steps with zero velocity, at boundary points, and at ordering crossings"
  artifacts:
    - src/evaluation/pipeline.py
    - src/analysis/spectrum.py
    - tests/test_spectrum.py
  key_links:
    - "pipeline.py stores S_qkt[:k] at each step in a separate spectrum_data dict"
    - "save_evaluation_results writes spectrum_trajectories.npz alongside token_metrics.npz"
    - "spectrum.py imports scipy.signal.savgol_filter for smoothing"
    - "spectrum.py provides compute_spectrum_analysis orchestrator returning curvature and torsion arrays"

<objective>
Extend the evaluation pipeline to store full singular value vectors and implement spectral curvature/torsion analysis with numerical safeguards.

Purpose: SPEC-01 requires storing full singular value vectors sigma_1..sigma_k per step in NPZ. SPEC-02 requires computing discrete Frenet-Serret curvature and torsion with appropriate numerical smoothing.
Output: Modified pipeline with spectrum storage, new analysis module with curvature/torsion, and comprehensive tests.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/references/tdd.md
@/root/.claude/get-shit-done/references/checkpoints.md
@/root/.claude/get-shit-done/references/model-profile-resolution.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-advanced-analysis/15-RESEARCH.md
@.planning/phases/15-advanced-analysis/15-CONTEXT.md

@src/evaluation/pipeline.py
@src/evaluation/svd_metrics.py
@src/analysis/auroc_horizon.py
@src/analysis/event_extraction.py
@src/results/schema.py

<interfaces>
<!-- Key types and contracts the executor needs. -->

From src/evaluation/pipeline.py:
```python
@dataclass
class EvaluationResult:
    generated: np.ndarray          # [n_sequences, max_steps]
    edge_valid: np.ndarray         # [n_sequences, max_steps-1]
    rule_outcome: np.ndarray       # [n_sequences, max_steps-1]
    failure_index: np.ndarray      # [n_sequences]
    svd_metrics: dict[str, np.ndarray]  # target.layer_N.metric -> [n_seqs, n_steps-1]
    guard_activations: dict[str, int]
    sequence_lengths: np.ndarray   # [n_sequences]

SVD_TARGETS = ["qkt", "wvwo", "avwo"]
SV_METRIC_NAMES = ["stable_rank", "spectral_entropy", ...]

def fused_evaluate(model, eval_walks, graph_data, jumpers, config, device, batch_size=32) -> EvaluationResult
def save_evaluation_results(result, output_dir, split_labels=None) -> dict[str, Any]
```

SVD is computed inside fused_evaluate's inner loop:
```python
U_qkt, S_qkt, Vh_qkt = torch.linalg.svd(qkt_clean, full_matrices=False)
# S_qkt has shape [B, k] where k = min(T, D)
# Currently S_qkt is only used to compute scalar metrics, then discarded
```

From src/graph/jumpers.py:
```python
R_SCALES: tuple[float, ...] = (0.5, 0.7, 0.9, 1.0, 1.1, 1.3, 1.5, 2.0)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create spectrum analysis module and tests</name>
  <files>
    src/analysis/spectrum.py
    tests/test_spectrum.py
  </files>
  <action>
Create `src/analysis/spectrum.py` implementing spectral curve analysis:

1. **Constants:**
   ```python
   DEFAULT_TOP_K = 8
   DEFAULT_SAVGOL_WINDOW = 7
   DEFAULT_SAVGOL_POLYORDER = 3
   VELOCITY_EPS = 1e-10  # threshold for zero-velocity guard
   ```

2. **`smooth_spectrum(spectra, window_length=7, polyorder=3)`:**
   - Input: spectra array of shape [n_steps, k]
   - Apply `scipy.signal.savgol_filter(spectra, window_length, polyorder, axis=0)`
   - If n_steps < window_length, return spectra unchanged (too short for smoothing)
   - Return smoothed array of same shape

3. **`detect_ordering_crossings(spectra)`:**
   - Input: spectra array of shape [n_steps, k], singular values assumed in descending order
   - For each pair (sigma_i, sigma_{i+1}), detect steps where sigma_i < sigma_{i+1} (an ordering swap)
   - Return boolean mask of shape [n_steps] where True means AT LEAST ONE ordering crossing at that step
   - A crossing at step t also marks steps t-1 and t+1 as invalid (derivative stencil contamination)

4. **`spectral_curvature(spectra, window_length=7, polyorder=3)`:**
   - Input: spectra array of shape [n_steps, k]
   - Apply smooth_spectrum
   - Detect ordering crossings on the ORIGINAL (unsmoothed) spectra
   - Compute first derivative: v = diff(smoothed, axis=0) -> [n_steps-1, k]
   - Compute second derivative: a = diff(v, axis=0) -> [n_steps-2, k]
   - For each step t (0 to n_steps-3):
     - v_t = v[t], a_t = a[t]
     - speed = ||v_t||
     - If speed < VELOCITY_EPS: curvature = NaN
     - Else: curvature = ||a_t - (a_t.v_hat)*v_hat|| / speed^2
       where v_hat = v_t / speed
   - Result array: [n_steps] with NaN padding at boundaries (first 2 and last 1 steps)
   - Apply ordering crossing mask: set curvature to NaN at crossing steps
   - Return curvature array of shape [n_steps]

5. **`spectral_torsion(spectra, window_length=7, polyorder=3)`:**
   - Input: spectra array of shape [n_steps, k]
   - Apply smooth_spectrum
   - Detect ordering crossings
   - Compute v, a (as above), and jerk: j = diff(a, axis=0) -> [n_steps-3, k]
   - For each step t (0 to n_steps-4):
     - Compute binormal direction b = a_t - (a_t.v_hat)*v_hat (perpendicular acceleration)
     - b_norm = ||b||
     - If b_norm < VELOCITY_EPS: torsion = NaN
     - Else: torsion = (j_t . b / ||b||) ... but for k dimensions, use the general formula:
       - Project jerk onto the normal plane: j_perp = j - (j.v_hat)*v_hat - (j.n_hat)*n_hat
         where n_hat = b / ||b||
       - torsion = ||j_perp|| / (speed * ||b||)  -- simplified for discrete case
     - Alternative simpler approach: torsion = det([v, a, j]) / ||v x a||^2
       For k > 3, use the generalized formula based on Gram matrix determinants
   - Result array: [n_steps] with NaN padding at boundaries (first 3 and last 1 steps)
   - Apply ordering crossing mask
   - Return torsion array of shape [n_steps]

   **Implementation note:** For simplicity and robustness in k dimensions, compute torsion as:
   ```python
   # Construct matrix M = [v; a; j] -> [3, k]
   # Torsion relates to how much the curve twists out of the osculating plane
   # Use: tau = ||j_perp_to_osculating_plane|| / (||v|| * ||kappa_vec||)
   # where kappa_vec = a - (a.v_hat)*v_hat
   ```

6. **`compute_spectrum_analysis(spectra, window_length=7, polyorder=3)`:**
   - Orchestrator: takes [n_steps, k] spectra, returns dict:
     ```python
     {
         "curvature": np.ndarray,   # [n_steps]
         "torsion": np.ndarray,     # [n_steps]
         "crossing_mask": np.ndarray,  # [n_steps] bool
         "smoothed": np.ndarray,    # [n_steps, k]
     }
     ```

7. **`compute_spectrum_analysis_batch(spectra_batch, ...)`:**
   - Takes [n_sequences, n_steps, k], applies compute_spectrum_analysis per sequence
   - Returns dict of arrays, each [n_sequences, n_steps]

Create `tests/test_spectrum.py`:

1. **test_smooth_spectrum_identity:** Apply smoothing to a perfectly linear trajectory sigma(t) = t * ones(k). After smoothing, should still be approximately linear. Check that max deviation < 1e-3.

2. **test_smooth_spectrum_short_sequence:** Spectrum with fewer steps than window_length. Should return unchanged.

3. **test_curvature_straight_line:** A straight-line trajectory sigma(t) = a + t*b in R^k. Curvature should be ~0 everywhere (within numerical tolerance). Use tolerance 1e-4.

4. **test_curvature_circle:** A circular trajectory in R^k (sigma(t) = [cos(t/N), sin(t/N), 0, ..., 0]) for N steps. Curvature should be approximately constant (1/radius). Verify within 10% of analytical value.

5. **test_curvature_boundary_padding:** Verify that the first 2 and last 1 entries of curvature array are NaN.

6. **test_curvature_zero_velocity:** Create trajectory that is constant for a segment (velocity=0). Curvature should be NaN at those steps.

7. **test_ordering_crossing_detection:** Create spectra where sigma_1 and sigma_2 swap at step t. Verify crossing mask is True at t-1, t, t+1.

8. **test_curvature_at_crossings_is_nan:** Combine crossing detection with curvature computation. Verify NaN at crossing steps.

9. **test_torsion_planar_curve:** A curve confined to a 2D plane in R^k. Torsion should be ~0 everywhere. Use tolerance 1e-4.

10. **test_torsion_helix:** A helical curve in R^k (sigma(t) = [cos(t/N), sin(t/N), t/N, 0, ..., 0]). Torsion should be approximately constant and nonzero.

11. **test_compute_spectrum_analysis_output_structure:** Verify that compute_spectrum_analysis returns dict with correct keys and shapes.

12. **test_compute_spectrum_analysis_batch:** Create batch of 3 sequences, verify output shapes are [3, n_steps] for curvature and torsion.

13. **test_curvature_noise_suppression:** Create a smooth curve with added Gaussian noise (sigma=0.001). Compare curvature with and without smoothing. Smoothed curvature should be closer to the true curvature of the noise-free curve.
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -m pytest tests/test_spectrum.py -x -v</automated>
  </verify>
  <done>
    - spectral_curvature correctly computes ~0 curvature for straight lines and ~constant for circles
    - spectral_torsion correctly computes ~0 for planar curves and ~constant for helices
    - Ordering crossings are detected and curvature/torsion masked to NaN
    - Zero-velocity and boundary steps produce NaN
    - Savitzky-Golay smoothing reduces noise in curvature estimates
    - Batch processing works correctly
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend evaluation pipeline with spectrum storage</name>
  <files>
    src/evaluation/pipeline.py
    tests/test_evaluation_pipeline.py
  </files>
  <action>
**Modify `src/evaluation/pipeline.py`:**

1. **Add EvaluationResult field:**
   Add `spectrum_data: dict[str, np.ndarray]` field to EvaluationResult dataclass:
   ```python
   spectrum_data: dict[str, np.ndarray] = field(default_factory=dict)
   # Keys: "qkt.layer_N.spectrum" -> [n_sequences, n_steps, k] float16
   ```

2. **Add constants:**
   ```python
   SPECTRUM_TOP_K = 8  # Number of top singular values to store
   SPECTRUM_TARGETS = ["qkt"]  # Only QK^T by default
   ```

3. **In fused_evaluate, pre-allocate spectrum arrays:**
   After the existing svd_metric_arrays allocation block, add:
   ```python
   # Pre-allocate spectrum trajectory storage (Phase 15: SPEC-01)
   spectrum_data: dict[str, np.ndarray] = {}
   spectrum_k = min(SPECTRUM_TOP_K, config.model.d_model, config.training.w)
   for target in SPECTRUM_TARGETS:
       for layer_idx in range(n_layers):
           key = f"{target}.layer_{layer_idx}.spectrum"
           spectrum_data[key] = np.full(
               (n_sequences, max_steps - 1, spectrum_k),
               np.nan,
               dtype=np.float16,
           )
   ```

4. **In the QK^T SVD inner loop, store S values:**
   After `U_qkt, S_qkt, Vh_qkt = torch.linalg.svd(...)`, before computing metrics:
   ```python
   # Store top-k singular values for spectrum trajectory (Phase 15: SPEC-01)
   if "qkt" in SPECTRUM_TARGETS:
       spec_key = f"qkt.layer_{layer_idx}.spectrum"
       if spec_key in spectrum_data:
           # S_qkt shape: [B, k_full] -- take top spectrum_k values
           s_top = S_qkt[:, :spectrum_k].cpu().to(torch.float16).numpy()
           for b_idx in range(B_actual):
               spectrum_data[spec_key][batch_start + b_idx, step, :] = s_top[b_idx]
   ```

5. **Add spectrum_data to EvaluationResult return:**
   ```python
   return EvaluationResult(
       ...,
       spectrum_data=spectrum_data,
   )
   ```

6. **In save_evaluation_results, write spectrum_trajectories.npz:**
   After writing token_metrics.npz, add:
   ```python
   # Write spectrum trajectories (Phase 15: SPEC-01)
   if result.spectrum_data:
       spectrum_path = output_path / "spectrum_trajectories.npz"
       np.savez_compressed(str(spectrum_path), **result.spectrum_data)
   ```

**Update existing tests in `tests/test_evaluation_pipeline.py`:**

Add a new test:
1. **test_spectrum_data_in_evaluation_result:** Construct a minimal EvaluationResult with spectrum_data containing a spectrum array. Verify it round-trips through save_evaluation_results by loading the spectrum_trajectories.npz and checking shape and dtype.

Ensure all existing evaluation pipeline tests still pass (spectrum_data defaults to empty dict via field default_factory, so backward compatibility is maintained).
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -m pytest tests/test_spectrum.py tests/test_evaluation_pipeline.py -x -v</automated>
  </verify>
  <done>
    - EvaluationResult has spectrum_data field defaulting to empty dict
    - fused_evaluate stores top-k QK^T singular values per step
    - save_evaluation_results writes spectrum_trajectories.npz with float16 arrays
    - Existing evaluation pipeline tests pass (no regressions from new field)
    - Spectrum NPZ round-trips correctly (save and load preserves shape/dtype)
    - All tests pass
  </done>
</task>

</tasks>

<verification>
- `pytest tests/test_spectrum.py -x -v` passes all spectrum analysis tests
- `pytest tests/test_evaluation_pipeline.py -x -v` passes (existing + new spectrum storage test)
- `pytest tests/ -x` full suite passes (no regressions)
- Curvature is ~0 for straight-line trajectories and ~constant for circular trajectories
- Torsion is ~0 for planar curves and ~constant for helices
- Spectrum storage uses float16 and separate NPZ file
</verification>

<success_criteria>
- SPEC-01: Full singular value vectors (top-k) stored per step in NPZ alongside existing scalar metrics, configurable per target (QK^T by default), float16 storage
- SPEC-02: Discrete Frenet-Serret curvature and torsion computed with Savitzky-Golay smoothing, ordering crossing detection, and appropriate numerical guards
- All tests pass including existing suite
</success_criteria>

<output>
After completion, create `.planning/phases/15-advanced-analysis/15-01-SUMMARY.md`
</output>
