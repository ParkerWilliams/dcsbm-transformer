---
phase: 02-dcsbm-graph-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/graph/__init__.py
  - src/graph/dcsbm.py
  - src/graph/degree_correction.py
  - src/graph/types.py
  - tests/test_graph_generation.py
autonomous: true
requirements:
  - GRPH-01
  - GRPH-03

must_haves:
  truths:
    - "generate_dcsbm_graph() with anchor config (n=500, K=4, p_in=0.25, p_out=0.03) returns a directed graph that is strongly connected"
    - "Generated graph has no self-loops (diagonal of adjacency matrix is all zeros)"
    - "Edge density within blocks matches p_in within 2-sigma statistical tolerance"
    - "Edge density between blocks matches p_out within 2-sigma statistical tolerance"
    - "Minimum expected degree across all vertices is >= 3"
    - "Degree correction with alpha=1.0 produces heterogeneous degree distribution (coefficient of variation > 0.3)"
    - "Theta values are normalized per-block so each block's theta sum equals block_size"
    - "Graph generation with retry produces valid graph within 10 attempts for anchor config"
  artifacts:
    - path: "src/graph/types.py"
      provides: "GraphData dataclass holding adjacency matrix, block assignments, theta values, and generation metadata"
      contains: "GraphData"
    - path: "src/graph/degree_correction.py"
      provides: "Theta sampling from Zipf distribution with per-block normalization"
      exports: ["sample_theta"]
    - path: "src/graph/dcsbm.py"
      provides: "DCSBM graph generator with degree correction, validation, and retry"
      exports: ["generate_dcsbm_graph"]
    - path: "src/graph/__init__.py"
      provides: "Public API re-exports"
      exports: ["generate_dcsbm_graph", "GraphData"]
  key_links:
    - from: "src/graph/dcsbm.py"
      to: "src/graph/degree_correction.py"
      via: "generate_dcsbm_graph calls sample_theta to get degree correction parameters"
      pattern: "sample_theta"
    - from: "src/graph/dcsbm.py"
      to: "src/config/experiment.py"
      via: "generate_dcsbm_graph accepts ExperimentConfig and reads graph/training sub-configs"
      pattern: "ExperimentConfig"
    - from: "src/graph/dcsbm.py"
      to: "scipy.sparse.csgraph"
      via: "Validation uses connected_components with directed=True, connection='strong'"
      pattern: "connected_components"
---

<objective>
Create the custom DCSBM graph generator with degree correction following Karrer & Newman 2011.

Purpose: This is the foundational graph generation module that all downstream phases depend on. Graphs serve as the substrate for random walks (Phase 3) which become transformer training data (Phase 5). The generator must produce valid, strongly connected directed graphs with configurable block structure and power-law degree heterogeneity mimicking token frequency distributions.

Output: `src/graph/` module with DCSBM generator, degree correction sampling, graph data types, and validation. Tests proving correctness of generation and validation for anchor config.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-dcsbm-graph-generation/02-CONTEXT.md
@.planning/phases/02-dcsbm-graph-generation/02-RESEARCH.md
@src/config/experiment.py
@src/config/hashing.py
@src/reproducibility/seed.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Graph data types and degree correction module</name>
  <files>
    pyproject.toml
    src/graph/__init__.py
    src/graph/types.py
    src/graph/degree_correction.py
  </files>
  <action>
**pyproject.toml update:**
- Add `scipy >= 1.14` to dependencies

**src/graph/types.py** — Graph data structures:

`GraphData` frozen dataclass with slots:
- `adjacency: scipy.sparse.csr_matrix` — directed adjacency (n x n)
- `block_assignments: np.ndarray` — int array of length n, vertex i in block block_assignments[i]
- `theta: np.ndarray` — float array of length n, degree correction parameters
- `n: int` — number of vertices
- `K: int` — number of blocks
- `block_size: int` — vertices per block (n // K)
- `generation_seed: int` — seed used for this specific generation attempt
- `attempt: int` — which retry attempt produced this graph (0-indexed)

Note: Use `@dataclass(frozen=True)` without `slots=True` since the class holds numpy/scipy objects that don't play well with slots (use `eq=False` to avoid numpy comparison issues). Override `__eq__` is not needed — identity comparison is fine for graph objects.

Actually, simplify: use a regular `@dataclass(frozen=True)` without slots, and do NOT set `eq=False`. The default frozen dataclass behavior is fine.

**src/graph/degree_correction.py** — Theta sampling:

`sample_theta(n: int, K: int, alpha: float, rng: np.random.Generator) -> np.ndarray`:
- Per CONTEXT.md: Zipf's law with alpha=1.0 (fixed, not swept)
- For each block b (b = 0..K-1):
  - block_size = n // K
  - Generate ranks 1..block_size
  - Compute raw theta: `1.0 / (ranks ** alpha)`
  - Shuffle raw values using rng to randomize which vertex gets which rank
  - Normalize so block's theta values sum to block_size: `theta[start:end] = raw * (block_size / raw.sum())`
- Assert each block's theta sum is within 1e-10 of block_size
- Return theta array of shape (n,)

**src/graph/__init__.py:**
- Re-export: `GraphData`, `sample_theta` (more exports added in later tasks)
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -c "
from src.graph.degree_correction import sample_theta
import numpy as np
rng = np.random.default_rng(42)
theta = sample_theta(500, 4, 1.0, rng)
assert theta.shape == (500,), f'Shape: {theta.shape}'
# Per-block normalization check
for b in range(4):
    block_sum = theta[b*125:(b+1)*125].sum()
    assert abs(block_sum - 125) < 1e-10, f'Block {b} sum: {block_sum}'
# Heterogeneity check (CV > 0.3)
cv = theta.std() / theta.mean()
assert cv > 0.3, f'CV too low: {cv}'
print(f'ALL CHECKS PASSED (CV={cv:.3f})')
"</automated>
  </verify>
  <done>
GraphData dataclass exists with all fields. sample_theta produces per-block normalized power-law theta values with coefficient of variation > 0.3. scipy added to project dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: DCSBM generator with validation and retry</name>
  <files>
    src/graph/dcsbm.py
    src/graph/__init__.py
    tests/test_graph_generation.py
  </files>
  <action>
**src/graph/dcsbm.py** — Core generator:

`class GraphGenerationError(Exception)`: Custom exception for generation failures.

`build_probability_matrix(n: int, K: int, p_in: float, p_out: float, theta: np.ndarray) -> np.ndarray`:
- Build K x K omega matrix: p_in on diagonal, p_out off-diagonal
- Compute block assignments: `blocks = np.arange(n) // (n // K)`
- Expand omega to n x n: `block_probs = omega[blocks][:, blocks]`
- Apply degree correction: `P = np.outer(theta, theta) * block_probs`
- Clip to [0, 1]: `np.clip(P, 0.0, 1.0, out=P)`
- Zero diagonal (no self-loops): `np.fill_diagonal(P, 0.0)`
- Return P

`sample_adjacency(P: np.ndarray, rng: np.random.Generator) -> scipy.sparse.csr_matrix`:
- `edges = (rng.random((n, n)) < P).astype(np.float64)`
- `np.fill_diagonal(edges, 0)` (redundant safety)
- Return `scipy.sparse.csr_matrix(edges)`

`validate_graph(adj: scipy.sparse.csr_matrix, P: np.ndarray, n: int, K: int, p_in: float, p_out: float) -> list[str]`:
- Check no self-loops: diagonal is zero
- Check strong connectivity: `connected_components(adj, directed=True, connection='strong')` returns n_components == 1
- Check minimum expected degree: for each vertex i, `P[i, :].sum() >= 3.0`. Note: use the probability matrix P, not the realized adjacency, per success criteria "minimum expected degree >= 3"
- Check edge density per block pair:
  - For each pair (a, b), compute observed = number of edges from block a to block b / (block_size * block_size if a != b, else block_size * (block_size - 1) for same block excluding diagonal)
  - Compute expected probability for this block pair. For same-block: mean of P[i,j] for i,j in block. For diff-block: mean of P[i,j].
  - Actually, simpler: compute observed density and expected density from the DCSBM model parameters. Expected for same block: p_in * mean(theta_a)^2 (approximately). But since we have P, just use mean(P[block_a, block_b]) as expected, and check |observed - expected| < 2 * sqrt(expected * (1 - expected) / n_pairs)
- Return list of error strings (empty = valid)

`generate_dcsbm_graph(config: ExperimentConfig, max_retries: int = 10) -> GraphData`:
- Extract n, K, p_in, p_out from config.graph
- Assert n % K == 0 (equal-sized blocks required per CONTEXT.md)
- degree_correction_alpha = 1.0 (hardcoded per CONTEXT.md locked decision)
- For attempt in range(max_retries):
  - rng = np.random.default_rng(config.seed + attempt)
  - theta = sample_theta(n, K, degree_correction_alpha, rng)
  - P = build_probability_matrix(n, K, p_in, p_out, theta)
  - adj = sample_adjacency(P, rng)
  - errors = validate_graph(adj, P, n, K, p_in, p_out)
  - If no errors: return GraphData(adjacency=adj, block_assignments=blocks, theta=theta, n=n, K=K, block_size=n//K, generation_seed=config.seed + attempt, attempt=attempt)
  - Else: log.warning with attempt number and errors
- Raise GraphGenerationError with last errors

Import and use Python logging: `log = logging.getLogger(__name__)`

**src/graph/__init__.py** update:
- Add re-exports: `generate_dcsbm_graph`, `GraphGenerationError`, `build_probability_matrix`, `validate_graph`

**tests/test_graph_generation.py** — pytest tests:

`test_anchor_config_generates_valid_graph()`:
- Use ANCHOR_CONFIG (n=500, K=4, p_in=0.25, p_out=0.03)
- Call generate_dcsbm_graph(ANCHOR_CONFIG)
- Assert returned GraphData has correct n, K, block_size
- Assert adjacency shape is (500, 500)
- Assert strong connectivity (verify with connected_components)
- Assert no self-loops

`test_degree_correction_heterogeneity()`:
- Generate graph with anchor config
- Compute realized degree per vertex: `adj.sum(axis=1).A1` (out-degree)
- Coefficient of variation > 0.3

`test_edge_density_within_tolerance()`:
- Generate graph with anchor config
- For each block pair, compute observed density
- Check within 2-sigma of expected (using the probability matrix mean for that block pair)

`test_minimum_expected_degree()`:
- Build probability matrix P for anchor config
- Check that P.sum(axis=1).min() >= 3.0

`test_no_self_loops()`:
- Generate graph, check adj.diagonal().sum() == 0

`test_validation_rejects_disconnected_graph()`:
- Create a manually disconnected graph (two components)
- validate_graph should return errors including "not strongly connected"

`test_retry_on_failure()`:
- Use a mock/monkeypatch to make the first attempt fail validation, verify that retry logic continues to next attempt

`test_equal_block_size_required()`:
- Create config with n=501, K=4 (not evenly divisible)
- Assert generate_dcsbm_graph raises ValueError or assertion error

`test_reproducibility_same_seed()`:
- Generate two graphs with same config and seed
- Assert adjacency matrices are identical (same edges)
  </action>
  <verify>
    <automated>cd /root/Repos/dcsbm-transformer && python -m pytest tests/test_graph_generation.py -v</automated>
  </verify>
  <done>
generate_dcsbm_graph produces a strongly connected directed graph for anchor config. Validation gates check connectivity, density, minimum expected degree, and self-loops. Retry mechanism increments seed on failure. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_graph_generation.py -v` — All generation and validation tests pass
2. `python -c "from src.graph import generate_dcsbm_graph, GraphData; from src.config import ANCHOR_CONFIG; g = generate_dcsbm_graph(ANCHOR_CONFIG); print(f'Generated: n={g.n}, K={g.K}, edges={g.adjacency.nnz}, attempt={g.attempt}')"` — Graph generates successfully
3. `python -c "from src.graph.dcsbm import build_probability_matrix; from src.graph.degree_correction import sample_theta; import numpy as np; theta = sample_theta(500, 4, 1.0, np.random.default_rng(42)); P = build_probability_matrix(500, 4, 0.25, 0.03, theta); print(f'Min expected degree: {P.sum(axis=1).min():.1f}')"` — Min expected degree >= 3
</verification>

<success_criteria>
- DCSBM graph generates for anchor config (n=500, K=4, p_in=0.25, p_out=0.03)
- Graph is strongly connected (verified by scipy.sparse.csgraph)
- No self-loops in adjacency matrix
- Edge density matches expected p_in/p_out within 2-sigma tolerance
- Minimum expected degree >= 3 across all vertices
- Degree correction produces heterogeneous degree distribution (CV > 0.3)
- Theta normalized per-block (each block sums to block_size)
- Retry mechanism works on validation failure
- Same seed produces identical graphs (reproducibility)
- All tests in tests/test_graph_generation.py pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-dcsbm-graph-generation/02-01-SUMMARY.md`
</output>
